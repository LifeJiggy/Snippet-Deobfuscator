/**
 * Malware Analysis Skill
 * Production-grade malware detection and analysis for JavaScript
 * Version: 3.0.0
 */
const { parse } = require("@babel/parser");
const { default: traverse } = require("@babel/traverse");
const { default: generate } = require("@babel/generator");

class MalwareAnalysisSkill {
  constructor() {
    this.name = "malware-analysis";
    this.version = "3.0.0";
    this.cache = new Map();
    this.stats = {
      critical: 0,
      high: 0,
      medium: 0,
      low: 0,
      total: 0,
    };
    this.patterns = this.initializePatterns();
    this.scoring = {
      critical: 10,
      high: 7,
      medium: 4,
      low: 1,
    };
  }

  execute(code, options = {}) {
    return this.analyze(code, options);
  }

  initializePatterns() {
    return {
      evalInjection: {
        pattern: /\beval\s*\(/g,
        severity: "critical",
        category: "code-injection",
        cwe: "CWE-94",
        description: "eval() can execute arbitrary code",
      },
      functionConstructor: {
        pattern: /\bFunction\s*\(/g,
        severity: "critical",
        category: "code-injection",
        cwe: "CWE-94",
        description: "Function constructor allows dynamic code execution",
      },
      setTimeoutString: {
        pattern: /setTimeout\s*\(\s*["'`]/g,
        severity: "high",
        category: "code-injection",
        cwe: "CWE-95",
        description: "setTimeout with string argument can execute code",
      },
      setIntervalString: {
        pattern: /setInterval\s*\(\s*["'`]/g,
        severity: "high",
        category: "code-injection",
        cwe: "CWE-95",
        description: "setInterval with string argument can execute code",
      },
      innerHTML: {
        pattern: /\.innerHTML\s*=/g,
        severity: "critical",
        category: "xss",
        cwe: "CWE-79",
        description: "innerHTML assignment can lead to XSS",
      },
      outerHTML: {
        pattern: /\.outerHTML\s*=/g,
        severity: "critical",
        category: "xss",
        cwe: "CWE-79",
        description: "outerHTML assignment can lead to XSS",
      },
      documentWrite: {
        pattern: /document\.write\s*\(/g,
        severity: "critical",
        category: "xss",
        cwe: "CWE-79",
        description: "document.write can lead to XSS",
      },
      protoPollution: {
        pattern: /__proto__|\.prototype\s*\[/g,
        severity: "critical",
        category: "prototype-pollution",
        cwe: "CWE-1321",
        description: "Prototype pollution vulnerability",
      },
      constructorPollution: {
        pattern: /constructor\s*\.\s*prototype/g,
        severity: "critical",
        category: "prototype-pollution",
        cwe: "CWE-1321",
        description: "Constructor prototype pollution",
      },
      locationHijack: {
        pattern: /location\.(href|replace|assign)\s*=/g,
        severity: "high",
        category: "redirection",
        cwe: "CWE-601",
        description: "Location manipulation can lead to phishing",
      },
      credentialHarvest: {
        pattern: /(password|token|secret|api_key|credential)\s*[=:]]/gi,
        severity: "high",
        category: "data-exfiltration",
        cwe: "CWE-200",
        description: "Potential credential handling",
      },
      networkBeacon: {
        pattern: /(fetch|XMLHttpRequest|WebSocket)\s*\(/g,
        severity: "medium",
        category: "network",
        cwe: "CWE-359",
        description: "Network communication detected",
      },
      localStorageAccess: {
        pattern: /localStorage\.(setItem|getItem)/g,
        severity: "medium",
        category: "storage",
        cwe: "CWE-522",
        description: "localStorage access detected",
      },
      sessionStorageAccess: {
        pattern: /sessionStorage\.(setItem|getItem)/g,
        severity: "medium",
        category: "storage",
        cwe: "CWE-522",
        description: "sessionStorage access detected",
      },
      coinhiveMining: {
        pattern: /CoinHive|cryptonight|hashrate|miner/gi,
        severity: "high",
        category: "cryptojacking",
        cwe: "CWE-400",
        description: "Cryptocurrency mining script detected",
      },
      packedCode: {
        pattern: /eval\s*\(\s*(atob|String\.fromCharCode)/g,
        severity: "high",
        category: "obfuscation",
        cwe: "CWE-506",
        description: "Packed/encoded malicious code",
      },
      selfDecoding: {
        pattern: /function\s*\(\s*p\s*,\s*a\s*,\s*c\s*,\s*k\s*,\s*e\s*\)/g,
        severity: "high",
        category: "obfuscation",
        cwe: "CWE-506",
        description: "Self-decoding function detected",
      },
      postMessage: {
        pattern: /postMessage\s*\(/g,
        severity: "medium",
        category: "communication",
        cwe: "CWE-346",
        description: "Cross-origin messaging detected",
      },
      execCommand: {
        pattern: /document\.execCommand\s*\(/g,
        severity: "medium",
        category: "dom",
        cwe: "CWE-79",
        description: "execCommand can be abused",
      },
      cookieAccess: {
        pattern: /document\.cookie/g,
        severity: "medium",
        category: "storage",
        cwe: "CWE-522",
        description: "Cookie access detected",
      },
    };
  }

  analyze(code, options = {}) {
    this.stats = { critical: 0, high: 0, medium: 0, low: 0, total: 0 };
    const result = {
      threats: [],
      score: 0,
      classification: "benign",
      statistics: {},
      recommendations: [],
      warnings: [],
      errors: [],
    };

    try {
      for (const [name, config] of Object.entries(this.patterns)) {
        const matches = code.match(config.pattern);
        if (matches && matches.length > 0) {
          result.threats.push({
            name,
            severity: config.severity,
            category: config.category,
            cwe: config.cwe,
            description: config.description,
            count: matches.length,
            samples: matches.slice(0, 3),
          });
          this.stats[config.severity]++;
          this.stats.total++;
          result.score += this.scoring[config.severity] * matches.length;
        }
      }

      const ast = this.parseCode(code);
      if (ast) {
        this.analyzeAST(ast, result);
      }

      result.classification = this.classify(result.score);
      result.statistics = this.getStatistics();
      result.recommendations = this.generateRecommendations(result.threats);
    } catch (error) {
      result.errors.push(error.message);
    }

    return result;
  }

  parseCode(code) {
    try {
      return parse(code, {
        sourceType: "unambiguous",
        plugins: ["jsx", "typescript"],
      });
    } catch (e) {
      return null;
    }
  }

  analyzeAST(ast, result) {
    traverse(ast, {
      CallExpression: (path) => {
        this.analyzeCallExpression(path, result);
      },
      AssignmentExpression: (path) => {
        this.analyzeAssignment(path, result);
      },
      MemberExpression: (path) => {
        this.analyzeMemberExpression(path, result);
      },
    });
  }

  analyzeCallExpression(path, result) {
    const callee = path.node.callee;

    if (callee.type === "Identifier") {
      if (callee.name === "eval") {
        this.addASTThreat(result, "eval-injection", "critical", path.node.loc);
      }
      if (callee.name === "Function") {
        this.addASTThreat(
          result,
          "function-constructor",
          "critical",
          path.node.loc
        );
      }
    }

    if (callee.type === "MemberExpression") {
      if (
        callee.object.name === "document" &&
        callee.property.name === "write"
      ) {
        this.addASTThreat(result, "document-write", "critical", path.node.loc);
      }
      if (callee.property.name === "innerHTML") {
        this.addASTThreat(result, "xss-innerHTML", "critical", path.node.loc);
      }
    }
  }

  analyzeAssignment(path, result) {
    const left = path.node.left;

    if (left.type === "MemberExpression") {
      if (left.property && left.property.name === "innerHTML") {
        this.addASTThreat(result, "xss-innerHTML", "critical", path.node.loc);
      }
      if (left.property && left.property.name === "outerHTML") {
        this.addASTThreat(result, "xss-outerHTML", "critical", path.node.loc);
      }
      if (
        left.property &&
        left.property.name === "href" &&
        left.object.name === "location"
      ) {
        this.addASTThreat(result, "location-hijack", "high", path.node.loc);
      }
    }
  }

  analyzeMemberExpression(path, result) {
    const node = path.node;

    if (node.property && node.property.name === "__proto__") {
      this.addASTThreat(result, "proto-pollution", "critical", path.node.loc);
    }
  }

  addASTThreat(result, name, severity, location) {
    result.threats.push({
      name,
      severity,
      category: "ast-detected",
      location: location ? this.getLocation(location) : null,
      method: "ast",
    });
    this.stats[severity]++;
    this.stats.total++;
    result.score += this.scoring[severity];
  }

  getLocation(loc) {
    if (!loc) return null;
    return {
      start: { line: loc.start.line, column: loc.start.column },
      end: { line: loc.end.line, column: loc.end.column },
    };
  }

  classify(score) {
    if (score >= 15) return "malicious";
    if (score >= 8) return "suspicious";
    return "benign";
  }

  generateRecommendations(threats) {
    const recommendations = [];

    const criticalThreats = threats.filter((t) => t.severity === "critical");
    if (criticalThreats.length > 0) {
      recommendations.push({
        priority: "critical",
        message:
          "Critical vulnerabilities detected - immediate remediation required",
        actions: criticalThreats.map((t) => `Remove or sanitize ${t.name}`),
      });
    }

    const evalThreats = threats.filter((t) => t.category === "code-injection");
    if (evalThreats.length > 0) {
      recommendations.push({
        priority: "high",
        message: "Code injection vectors detected",
        actions: [
          "Replace eval() with safer alternatives",
          "Validate all inputs",
        ],
      });
    }

    const xssThreats = threats.filter((t) => t.category === "xss");
    if (xssThreats.length > 0) {
      recommendations.push({
        priority: "high",
        message: "XSS vulnerabilities detected",
        actions: [
          "Use textContent instead of innerHTML",
          "Implement CSP headers",
        ],
      });
    }

    const protoThreats = threats.filter(
      (t) => t.category === "prototype-pollution"
    );
    if (protoThreats.length > 0) {
      recommendations.push({
        priority: "critical",
        message: "Prototype pollution vulnerabilities detected",
        actions: ["Use Object.create(null)", "Freeze Object.prototype"],
      });
    }

    return recommendations;
  }

  getStatistics() {
    return {
      ...this.stats,
      scorePerIssue:
        this.stats.total > 0 ? (this.score / this.stats.total).toFixed(2) : 0,
    };
  }

  getScore() {
    let score = 0;
    for (const [severity, count] of Object.entries(this.stats)) {
      if (severity !== "total" && this.scoring[severity]) {
        score += this.scoring[severity] * count;
      }
    }
    return score;
  }

  clearCache() {
    this.cache.clear();
  }

  dispose() {
    this.cache.clear();
    this.patterns = {};
  }
}

module.exports = MalwareAnalysisSkill;
